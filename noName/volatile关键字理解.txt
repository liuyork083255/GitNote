
volatile两大作用

	1、保证内存可见性
	2、防止指令重排

	此外需注意volatile并不保证操作的原子性。
	

必须知道：
	在使用volatile关键字时要慎重，并不是只要简单类型变量使用volatile修饰，对这个变量的所有操作都是原来操作，当变量的值由自身的上一个决定时，
	如n=n+1、n++ 等，volatile关键字将失效，只有当变量的值和自身上一个值无关时对该变量的操作才是原子级别的，如n = m + 1，这个就是原级别的。
	所以在使用volatile关键时一定要谨慎，如果自己没有把握，可以使用synchronized来代替volatile。


首先要了解 线程的内存和jvm主内存相关概念，然后了解对变量的加载流程
	可以参考 http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html

	如果加了 volatile 那么就表示，所有线程中的这个变量立马同步成最新的值。

其实这样理解：
	当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
	所以对于原子操作，就不要考虑变量变化了还要写入内存机制，系统会自动做到如果这个变量变化了立马同步到内存中，这个时候别的线程来读就会
	到内存中去读，所以读取到的是最新的值

	而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，
	此时内存中可能还是原来的旧值，因此无法保证可见性。

	这里有一点不好理解，就是如果一个变量volatile修饰，然后线程1读，线程2写，线程2写的事件肯定会发生在线程1读之前，这个java虚拟机
	的happens-before八大之一原则保证的。系统自动会判断出是读还是写，如果是写，那么别的不管有多少线程去读，都会发生在写这个线程的后面。
	但是如果写不是原子操作，比如i++  i = i + 1这样的操作，那么这个过程是读写两个操作，也就是上面的线程2的写操作，也变成了两个操作。

	还要哦补充一点，如果两个线程1和线程2，都去读被volatile修饰的变量，并且两个都读取到了自己的缓存中，如果线程1立马修改值，这个时候
	线程2缓存中值立马失效，然后回去jvm内存中去重新读取。
	
	volatile保证的是可见性，可以这么理解，cpu读取一个变量，如果这个变量被这个修饰，那么cpu以后就不会从高速缓存中读取，而是每次读的时候都从
	内存中读取。同时还要注意，i = 1；i++；这样的操作，cpu只会读取一次
		例如：
			i++操作：线程1中，cpu首先是会读取到缓存中，但是还没有来得及增1，另一个线程2修改了这个值，并且写入了内存中，但是不对线程1影响，因为
			线程1已经读取了，后面的操作是+1，最后写入。所以会有并发操作。
			
			但是如果线程1还要进行读取，那么这个时候就会读取到新的值，因为线程2改的值会立马写入到内存中的。
			

		注意这么一句话：对volatile字段的写操作创建了一个内存屏障，这个屏障将刷新所有缓存里的值。
			这个缓存指的是所有的线程缓存



