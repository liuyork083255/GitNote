回顾一下 事务中的四中冲突（注意：他们都是基于事务中的概念）：

1、脏读
	某个事务读取的数据是另一个事务正在处理的数据。而另一个事务可能会回滚，造成第一个事务读取的数据是错误的。

2、不可重复读
	在一个事务里两次读入数据，但另一个事务已经更改了第一个事务涉及到的数据，造成第一个事务读入旧数据。

3、幻读
	幻读是指当事务不是独立执行时发生的一种现象。例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。
	同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。
	那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

4、更新丢失
	多个事务同时读取某一数据，一个事务成功处理好了数据，被另一个事务写回原值，造成第一个事务更新丢失。


回顾事务的ACID特性

1、A (Atomicity)  原子性
	事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。

2、C (Consistency)一致性
	事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。
	事务结束时，所有的内部数据结构（如 B树索引或双向链表）都必须是正确的。

3、I (Isolation)   隔离性 
	并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务识别数据时数据所处的状态，要么是另一并发事务修改它之前的状态，
	要么是第二个事务修改它之后的状态，事务不会识别中间状态的数据。

4、D (Durability)  持久性
	事务完成之后，它对于系统的影响是永久性的。该修改即使出现系统故障也将一直保持。





脏数据：
　　脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这
个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据(Dirty Data)，依据脏数据所做的操作可能是不正确的。

不可重复读：
　　不可重复读是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。
那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。
这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读



悲观锁(Pessimistic Locking):  
	也就是在一个事物当中调用开启悲观锁，然后，直到这个事务提交之前，别的所有的对这些数据进行修改都会被阻塞状态。

	一个典型的倚赖数据库的悲观锁调用： 
       select * from account where name=”Erica” for update
       这条 sql 语句锁定了 account 表中所有符合检索条件（ name=”Erica” ）的记录。
       本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。




乐观锁（ Optimistic Locking）：
一般来说有以下2种方式：
	1.使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？
		即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。
		当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。
		当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，
		如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。

	2.乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，
		名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，
		也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。


		

注意：在解决同步和并发问题上，如果是单系统，那么可以选择采用代码的方式进行加锁，或者是采用数据库的悲观锁活着是乐观锁进行加锁。
	但是如果是分布式系统，并且同步的数据在数据库中，那么就采用数据库的悲观锁和乐观锁。
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		





