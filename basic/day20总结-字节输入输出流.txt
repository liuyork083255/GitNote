1:递归(理解)
	(1)方法定义中调用方法本身的现象
		举例：老和尚给小和尚讲故事，我们学编程
	(2)递归的注意事项；
		A:要有出口，否则就是死递归
		B:次数不能过多，否则内存溢出
		C:构造方法不能递归使用
	(3)递归的案例：
		A:递归求阶乘
		B:兔子问题
		C:递归输出指定目录下所有指定后缀名的文件绝对路径
		D:递归删除带内容的目录(小心使用)

2:IO流(掌握)
	(1)IO用于在设备间进行数据传输的操作	
	(2)分类：
		A:流向
			输入流	读取数据
			输出流	写出数据
		B:数据类型
			字节流	
					字节输入流
					字节输出流
			字符流
					字符输入流 
					字符输出流
		注意：
			a:如果我们没有明确说明按照什么分，默认按照数据类型分。
			b:除非文件用windows自带的记事本打开我们能够读懂，才采用字符流，否则建议使用字节流。

	(3)FileOutputStream写出数据----它是字节输出流的子类，注意，这个流在操作文件时，别的流是不可以操作这个文件的
		 * 		FileOutputStream(File file)              
		 *		FileOutputStream(String name)        这两个构造是一个意思
                		注意：	这两个构造只要一构造，就会将文件创造出来，如果本来就有了，------但是前面的路径必须存在，不然报错
					就会更新里面的内容，注意：这只是还在构造的时候就做了这些事情

		A:操作步骤
			a:创建字节输出流对象
			b:调用write()方法---------------因为这是输出，所以主要学习这个方法
			c:释放资源    -----------这一步很重要，虽然上面写入方法已经可以了，但是这个步骤会通知系统去释放相关资源，养成习惯
			
		B:代码体现：
			FileOutputStream fos = new FileOutputStream("fos.txt");
			
			fos.write("hello".getBytes());
			
			fos.close();
			
		C:要注意的问题?
			a:创建字节输出流对象做了几件事情?
				 ---1创建文件（注意：是先创建文件后才是对象） 2创建对象  3把对象指向文件

			b:为什么要close()?
			c:如何实现数据的换行?           
				------\n换行--------------其实out.write("hel\nlo java".getBytes());这样就可以了，不用两个\

 		 		为什么现在没有换行呢?因为你值写了字节数据，并没有写入换行符号。
		  		如何实现呢?写入换行符号即可呗。
		  		刚才我们看到了有写文本文件打开是可以的，通过windows自带的那个不行，为什么呢?
		  		因为不同的系统针对不同的换行符号识别是不一样的?
		  		windows:\r\n
		  		linux:\n
		  		Mac:\r
		  		而一些常见的个高级记事本，是可以识别任意换行符号的。
				解决：以后会学习专门识别系统的换行符

			d:如何实现数据的追加写入?
				上面的这写入每次都是更新后再写，不会追加
		 		 FileOutputStream(File file，boolean append)              
		 		 FileOutputStream(String name，boolean append)     这两种都在后面加上true即可

			e:异常处理：就是对象在try外面，close在finally里面，注意在finally里面要判断释放的对象是否为空


	(4)FileInputStream读取数据
		A:操作步骤
			a:创建字节输入流对象
			b:调用read()方法
				----这个方法，每次取一个字符，但是下次调用会取下一个，类似迭代器
				---如果完了还读，则会返回-1，所以可以循环读取
				---读的时候是读取的字节，返回的是int，所以要char，但是如果遇到中文，这会乱码，因为中文两个字节被转成一个字节了
			c:释放资源
			
		B:代码体现：
			FileInputStream fis = new FileInputStream("fos.txt");----这个没有无参构造  
			
			//方式1
			int by = 0;
			while((by=fis.read())!=-1) {   -------------注意这个返回值读到字符的int，不是长度
				System.out.print((char)by);
			}
			
			//方式2
			byte[] bys = new byte[1024];
			int len = 0;
			while((len=fis.read(bys))!=-1) {----注意：这里的返回值而是一次性读到字符的个数，而不是上面的char的int值
							----注意：读到数组中，内部也是一个一个读，自动循环，while是控制整个数组读满了循环
				System.out.print(new String(bys,0,len));
			}
			----------------方式2其实可以读中文，但是如果刚好到1024被分开，这个那个中文会乱码，一半在前面一半在后面
			fis.close();

	(5)案例：2种实现
		A:复制文本文件---------------------字节读取，没有做任何的转换，则可以读取任何类型的文件
			---计算机识别中文，中文在计算机中存储两个字节，
			---第一个肯定是负数，第二个可正可负，只要第一个为负，则自动拼接后一个,形成两个字节
		B:复制图片
		C:复制视频
	(6)字节缓冲区流
		它与字节流的区别：（当然！！！只是在输出流的区别）
		----------首先必须知道不管是写入写出，都是先写到缓冲区，要flust刷新才会写入。
		----------如果没有flust直接close也可以它包含了flust。
		-----------因为java考虑到读大量数据数组方便，所以专门设计了这种方法，理解成自带数组的字节流（缓冲区实现的）
			---------------注意：输入流是没有flush的------也就是说BufferedInputStream没有flush方法
-----------------------
web后期视频提到，缓冲区其实就是先将数据读/取到内存中个，读的话再从内存中一个区，所以没有flash，但是写则是先
写到内存中，调用flush和close才会将内存中的值全部写入硬盘中
----------------------


		A:BufferedOutputStream
			BufferedOutputStream(OutputStream out)----------------方法还是主要掌握write
			BufferedOutputStream(OutputStream out，int size)----------------方法还是主要掌握write
			* 为什么不传递一个具体的文件或者文件路径，而是传递一个OutputStream对象呢?
			* 原因很简单，字节缓冲区流仅仅提供缓冲区，为高效而设计的。但是呢，真正的读写操作还得靠基本的流对象实现。-----装饰者模式

			构造方法可以指定缓冲区的大小，但是我们一般用不上，因为默认缓冲区大小就足够了。
			注意：
			最后还是要释放资源，因为有两个资源，2其实释放最外面一个就可以了，参数中的那个也会内部自动释放

		B:BufferedInputStream
			BufferedInputStream(InputStream in)
			BufferedInputStream(InputStream in，int size)
			 * 注意：虽然我们有两种方式可以读取，但是，请注意，这两种方式针对同一个对象在一个代码中只能使用一个。
			意思就是我们是对缓冲区中的数据操作，我们前面都已经读到最后了，那么还用这个缓冲区读，他本来就到最后了，第二次肯定
			读出来时空，除非让该字节流重新装入数据
			最后效率测试下来：
				 * 基本字节流一次读写一个字节：	共耗时：117235毫秒
				 * 基本字节流一次读写一个字节数组： 共耗时：156毫秒
				 * 高效字节流一次读写一个字节： 共耗时：1141毫秒
				 * 高效字节流一次读写一个字节数组： 共耗时：47毫秒------------这才是我们以后要用的
					---思想就是先将数据从输入流读入到指定的数组中，然后再从数组中转入到输出流中

			--------------------------注意：它的读取其实和FileInputStream读取式样的


	(7)案例：4种实现
		A:复制文本文件
		B:复制图片
		C:复制视频
			----一次读一个字节来复制视频，效率很低，则可以一次读取一个字节数组	数组读取返回的是读取的个数
			----如果数组读到后面过长了，则后面的出现的在高版本jdk会出现方框，低版本的jdk出现空格。
			----所以，我们用数组来取是必须动态判断实际取得字节数.
			----代码如下：
				// 最终版代码
				// 数组的长度一般是1024或者1024的整数倍
				byte[] bys = new byte[1024];
				int len = 0;
				while ((len = fis.read(bys)) != -1) {-----这个方法自动识别，读取完后就返回-1
					System.out.print(new String(bys, 0, len));
				}
		
3:自学字符流
	IO流分类
		字节流：
			InputStream-------------所有输入字节流的超类
				FileInputStream
				BufferedInputStream
			OutputStream-------------所有输出字节流的超类
				FileOutputStream
				BufferedOutputStream
		
		字符流：
			Reader-------------所有输入字符流的超类
				FileReader
				BufferedReader
			Writer-------------所有输出字符流的超类
				FileWriter
				BufferedWriter