1:List的子类(掌握)
	(1)List的子类特点
		ArrayList:
			底层数据结构是数组，查询快，增删慢
			线程不安全，效率高
		Vector:
			底层数据结构是数组，查询快，增删慢
			线程安全，效率低
		LinkedList:
			底层数据结构是链表，查询慢，增删快
			线程不安全，效率高
	(2)ArrayList
		A:没有特有功能需要学习
		B:案例
			a:ArrayList存储字符串并遍历
			b:ArrayList存储自定义对象并遍历
	(3)Vector
		A:有特有功能
			a:添加
				public void addElement(E obj)		--	add()
			b:获取
				public EelementAt(int index)		--	get()
				public Enumeration<E> elements()	--  iterator()
		B:案例
			a:Vector存储字符串并遍历
			b:Vector存储自定义对象并遍历
	(4)LinkedList
		A:有特有功能	
			a:添加
				addFirst()
				addLast()
			b:删除
				removeFirst()
				removeLast()
			c:获取
				getFirst()
				getLast()
		B:案例
			a:LinkedList存储字符串并遍历
			b:LinkedList存储自定义对象并遍历
	(5)案例：
		A:去除集合中的多个字符串的重复元素
			如果字符串的内容相同，即为重复元素
		B:去除集合中的多个自定义对象的重复元素
			如果自定义对象的成员变量值都相同，即为重复元素-------------contains底层以来equals，所以要重写
----------------------------------------------------
可以利用两个集合来做，这个简单，如果利用一个集合：
		for (int x = 0; x < array.size() - 1; x++) {
			for (int y = x + 1; y < array.size(); y++) {
				if (array.get(x).equals(array.get(y))) {
					array.remove(y);
					y--; -------------------关键就是这一步。考虑到多个连续相同的在一起，y必须后退一步，才能删除完毕
				}
			}
		}

----------------------------------------------------

		C:用LinkedList模拟一个栈数据结构的集合类，并测试。
			你要定义一个集合类，只不过内部可以使用LinkedList来实现。
---------------------------------------------
	private LinkedList link;

	public MyStack() {
		link = new LinkedList();
	}

	public void add(Object obj) {
		link.addFirst(obj);
	}

	public Object get() {
		// return link.getFirst();
		return link.removeFirst();
	}

	public boolean isEmpty() {
		return link.isEmpty();
	}
--------------------------------------------------

2:泛型(掌握)
	(1)泛型概述
		是一种把明确类型的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。
	(2)格式：
		<数据类型>
		注意：该数据类型只能是引用类型。
	(3)好处：
		A:把运行时期的问题提前到了编译期间
		B:避免了强制类型转换
		C:优化了程序设计，解决了黄色警告线问题，让程序更安全
	(4)泛型的前世今生
		A:泛型的由来
			Object类型作为任意类型的时候，在向下转型的时候，会隐含一个转型问题
		B:泛型类
			

		C:泛型方法
			------------public <T> void show(T t){ ---------------这样子定义后就可以打印任意类型的数据了
					System.out.println(t);
				    }

		D:泛型接口

		E:泛型高级通配符
			?：
				----------------注意：ArrayList<Object> o = new ArrayList<Object>();再给出了明确类型后，前后必须一致。
				----------------ArrayList<?> o = new ArrayList<Object>();但是前面是?,则后面可以是任意类型
			? extends E：    
				-------------ArrayList<? extends E> o = new ArrayList<A>();表示A必须是E类型，或者是她的子类
			? super E
				-------------这个则是相反，必须是本身或者是她的父亲。
	(5)我们在哪里使用呢?
		一般是在集合中使用。
	
3:增强for循环(掌握)--------------------其实就是替代迭代器的，所以在循环的时候不可以改变集合
	(1)是for循环的一种
	(2)格式：
		for(元素的数据类型 变量名 : 数组或者Collection集合的对象) {
			使用该变量即可，该变量其实就是数组或者集合中的元素。
		}
	(3)好处：
		简化了数组和集合的遍历
	(4)弊端
		增强for循环的目标不能为null。建议在使用前，先判断是否为null。---------------这点记住
 	
4:静态导入(了解)-------------------------------------静态导入后，就可以省略Math.abs(123)的Math
	(1)可以导入到方法级别的导入
	(2)格式：
		import static 包名....类名.方法名;
	(3)注意事项：
		A:方法必须是静态的
		B:如果多个类下有同名的方法，就不好区分了，还得加上前缀。
			所以一般我们并不使用静态导入，但是一定要能够看懂。
	
5:可变参数(掌握)
	(1)如果我们在写方法的时候，参数个数不明确，就应该定义可变参数。
	(2)格式：
		修饰符 返回值类型 方法名(数据类型... 变量) {}--------------内部可用增强for来获取每个参数
		
		注意：
			A:该变量其实是一个数组名
			B:如果一个方法有多个参数，并且有可变参数，可变参数必须在最后
					------------------也就是这种 int sum(int... a,int b):这种是不行的，可变的必须放在最后
	(3)Arrays工具类的一个方法
		asList()把数组转成集合。------------注意：参数是可变参数
				---------List<String> list = Arrays.asList("asdf","fds");这里可以一个参数都不给，也可以多个，也可以是数组
		注意：这个集合的长度不能改变。
				---------也就是说他的本质还是数组，长度不能改变，对应的增删就不能操作，但是可以改变元素值 	

6:练习(掌握)
	A:集合的嵌套遍历----------就是集合里面存储的还是集合
	B:产生10个1-20之间的随机数，要求随机数不能重复
	C:键盘录入多个数据，以0结束，并在控制台输出最大值
	
7:要掌握的代码
	集合存储元素，加入泛型，并可以使用增强for遍历。




























