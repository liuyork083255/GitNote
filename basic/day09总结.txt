1:final关键字(掌握)
	(1)是最终的意思，可以修饰类，方法，变量。
	(2)特点：  
		A:它修饰的类，不能被继承。    ----------可以实例化
		B:它修饰的方法，不能被重写。
		C:它修饰的变量，是一个常量。
	(3)面试相关：
		A:局部变量
---------------------------------------------------------------
注意：final修饰成员变量则是将成员变量直接定义为了常量，反编译中还在，并没哟消失，说明内存中还存在

如果是修饰局部变量，则不但定义成了常量，而且在反编译后的代码中看不到定义的final int a = 100；后面的a都换成了100，说明内存中已经没有了该变量
---------------------------------------------------------------
			a:基本类型 值不能发生改变
			b:引用类型 地址值不能发生改变，但是对象的内容是可以改变的
		B:初始化时机
			a:只能初始化一次。
			b:常见的给值
				定义的时候。(推荐)
				构造方法中。
		
	注意：如果修饰成员变量则在定义的时候给定初始值，不然报错，但是修饰局部变量，定义的时候可以先不用初始化	


2:多态(掌握)-------------------------注意：继承中可以对静态方法重写，但是在多态中，对静态方法没有多态特性


注意：在继承中，子类和父类方法对于static修饰要么都有要么都没有，否则报错
	如果都有，则没有多态效果，会使用父类的方法，不会调用子类的方法

---------------------------------------------------------------------------------------------------------------

	(1)同一个对象在不同时刻体现出来的不同状态。 --------------new的时候，从右边往左边念   后者是前者
	(2)多态的前提：
		A:有继承或者实现关系。
		B:有方法重写。
		C:有父类或者父接口引用指向子类对象。
		
		多态的分类：
			a:具体类多态
				class Fu {}
				class Zi extends Fu {}
				
				Fu f = new Zi();
			b:抽象类多态
				abstract class Fu {}
				class Zi extends Fu {}
				
				Fu f = new Zi();
			c:接口多态
				interface Fu {}
				class Zi implements Fu {}
				
				Fu f = new Zi();
	(3)多态中的成员访问特点
		A:成员变量
			编译看左边，运行看左边
		B:构造方法
			子类的构造都会默认访问父类构造
		C:成员方法
			编译看左边，运行看右边
		D:静态方法
			编译看左边，运行看左边  ------------------静态和类相关，算不上重写，所以还是看左边
			
		为什么?
			因为成员方法有重写。
	(4)多态的好处：
		A:提高代码的维护性(继承体现)
		B:提高代码的扩展性(多态体现)
	(5)多态的弊端：
		父不能使用子的特有功能。
		
		现象：
			子可以当作父使用，父不能当作子使用。
	(6)多态中的转型---------------后面的向前面转
		A:向上转型
			从子到父   ---Fu f = new Zi();   
		B:向下转型
			从父到子   ---Zi z = （Zi）f;-------------这个要强转---------但是f = （Zi）f；这样还是没有转成功
	(7)孔子装爹的案例帮助大家理解多态
	(8)多态的练习
		A:猫狗案例
		B:老师和学生案例
----------------------------------------------------------------------------多看几遍多态内存图解
--------------------------------------------------------------
fu f = new zi();
注意：：这种方式，fu的引用只能访问fu中的成员数据，如果访问的方法被继承则，则调用子类对应的方法，不能访问zi的
--------------------------------------------------------------
3:抽象类(掌握)

--------------------------注意abstract关键字修饰类的时候，必须放在class前面

	(1)把多个共性的东西提取到一个类中，这是继承的做法。
	   但是呢，这多个共性的东西，在有些时候，方法声明一样，但是方法体。
	   也就是说，方法声明一样，但是每个具体的对象在具体实现的时候内容不一样。
	   所以，我们在定义这些共性的方法的时候，就不能给出具体的方法体。
	   而一个没有具体的方法体的方法是抽象的方法。
	   在一个类中如果有抽象方法，该类必须定义为抽象类。
	(2)抽象类的特点
		A:抽象类和抽象方法必须用关键字abstract修饰
		B:抽象类中不一定有抽象方法,但是有抽象方法的类一定是抽象类
		C:抽象类不能实例化
		D:抽象类的子类
			a:是一个抽象类。
			b:是一个具体类。这个类必须重写抽象类中的所有抽象方法。
	(3)抽象类的成员特点：
		A:成员变量
			有变量，有常量
		B:构造方法
			有构造方法--------------------------它是有构造方法，因为子类继承它要用
		C:成员方法
			有抽象，有非抽象
	(4)抽象类的练习
		A:猫狗案例练习
		B:老师案例练习
		C:学生案例练习
		D:员工案例练习
	(5)抽象类的几个小问题
		A:抽象类有构造方法，不能实例化，那么构造方法有什么用?
			用于子类访问父类数据的初始化
		B:一个类如果没有抽象方法,却定义为了抽象类，有什么用?
			为了不让创建对
		C:abstract不能和哪些关键字共存
			a:final	冲突               -------如果加了就是最终的意思，也不能被重写 没有意思
			b:private 冲突             -------如果加了private 就不能让子类重写，没有意义了
			c:static 无意义            -------静态的可以通过类名调用，明显没有意义

----------------------------------------------------------------------------------
掌握abstract 和 final 分别修饰类、方法的含义
----------------------------------------------------------------------------------
4:接口(掌握)
	(1)回顾猫狗案例，它们仅仅提供一些基本功能。
	   比如：猫钻火圈，狗跳高等功能，不是动物本身就具备的，
	   是在后面的培养中训练出来的，这种额外的功能，java提供了接口表示。
	(2)接口的特点：
		A:接口用关键字interface修饰
			interface 接口名 {}
		B:类实现接口用implements修饰
			class 类名 implements 接口名 {}
		C:接口不能实例化
		D:接口的实现类
			a:是一个抽象类。
			b:是一个具体类，这个类必须重写接口中的所有抽象方法。
	(3)接口的成员特点：
		A:成员变量
			只能是常量
			默认修饰符：public static final           ----------------可以通过接口名来调用变量是可以的，得到证明
			---------------还要注意：实现类是可以使用接口中的常量，这里有点类似继承关系

		B:构造方法
			没有构造方法               ------------所以子类实现接口并不是访问接口的构造，而是Object，抽象类是有的
		C:成员方法
			只能是抽象的
			默认修饰符：public abstract            --------说明接口方法不能带主体，不然报错
								只要加了abstract就不可以加主体

	(4)类与类,类与接口,接口与接口
		A:类与类
			继承关系，只能单继承，可以多层继承
		B:类与接口
			实现关系，可以单实现，也可以多实现。
			还可以在继承一个类的同时，实现多个接口
		C:接口与接口
			继承关系，可以单继承，也可以多继承       --------注意：是继承extends 而不是implements

	(5)抽象类和接口的区别(自己补齐)?
		抽象类和接口的区别：
		A:成员区别
			抽象类：
				成员变量：可以变量，也可以常量
				构造方法：有
				成员方法：可以抽象，也可以非抽象
			接口：
				成员变量：只可以常量
				成员方法：只可以抽象
		
		B:关系区别
			类与类
				继承，单继承
			类与接口
				实现，单实现，多实现
			接口与接口
				继承，单继承，多继承-----------所以说继承是可以多继承，针对的是接口
		
		C:设计理念区别
			抽象类 被继承体现的是：”is a”的关系。抽象类中定义的是该继承体系的共性功能。
			接口 被实现体现的是：”like a”的关系。接口中定义的是该继承体系的扩展功能。
	(6)练习：
		A:猫狗案例，加入跳高功能
		B:老师和学生案例，加入抽烟功能0




















