1:如何制作帮助文档(了解)
	(1)写一个类
	(2)加入文档注释
	(3)通过javadoc工具生成即可
		javadoc -d 目录 -author -version ArrayTool.java
                 目录：              ---------------这个是表示将这个工具生成放在哪里
		 ArrayTool.java ：   ---------------这个是要生成工具的类
	注意：该类必须有public修饰



2:通过JDK提供的API学习了Math类(掌握)
	(1)API(Application Programming Interface)
		应用程序编程接口(帮助文档)
	(2)如何使用呢?
		请参照
			day08\code\02_如何使用JDK提供的帮助文档\如何使用帮助文档.txt
	(3)Math类
		A:是针对数学进行操作的类
		B:没有构造方法，因为它的成员都是静态的
		C:产生随机数
			public static double random(): [0.0,1.0)
		D:如何产生一个1-100之间的随机数
			int number = (int)(Math.random()*100)+1;
		E:猜数字小游戏

-----------------------------------------------------------------
想让一个类不被创建，则可以将其构造方法私有化
-----------------------------------------------------------------
 
3:代码块(理解)
	(1)用{}括起来的代码。
	(2)分类：
		A:局部代码块
			用于限定变量的生命周期，及早释放，提高内存利用率。  
			-------------------比如在方法中定义代码块

		B:构造代码块-------------------------每次调用构造方法之前都会执行构造代码块，不管调用那个构造方法 
			把多个构造方法中相同的代码可以放到这里，每个构造方法执行前，首先执行构造代码块。---------这里面是可以放输出语句的
		        因为其每次创建一个新的对象都会被执行，所以它是用来对 对象进行初始化的
			只有创建对象才执行，别的方法都不执行
			----------------------------------是放在类中方法外

		C:静态代码块
			对类的数据进行初始化，仅仅只执行一次。----------它要执行在构造代码块之前

	(3)静态代码块,构造代码块,构造方法的顺序问题?
		静态代码块 > 构造代码块 > 构造方法
		注意了   静态成员初始化和 静态代码块的顺序是等同的，谁在前面谁先执行
			 同理非静态成员和非静态代码块也是等同级别

	
4:继承(掌握)
	(1)把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，
	   这多个类就具备了这些内容。这个关系叫继承。
	(2)Java中如何表示继承呢?格式是什么呢?
		A:用关键字extends表示
		B:格式：
			class 子类名 extends 父类名 {}
	(3)继承的好处：
		A:提高了代码的复用性
		B:提高了代码的维护性
		C:让类与类产生了一个关系，是多态的前提
	(4)继承的弊端：
		A:让类的耦合性增强。这样某个类的改变，就会影响其他和该类相关的类。
			原则：低耦合，高内聚。
			耦合：类与类的关系
			内聚：自己完成某件事情的能力
		B:打破了封装性
	(5)Java中继承的特点
		A:Java中类只支持单继承
		B:Java中可以多层(重)继承(继承体系)
	(6)继承的注意事项：
		A:子类不能继承父类的私有成员
		B:子类不能继承父类的构造方法，但是可以通过super去访问
		C:不要为了部分功能而去继承
	(7)什么时候使用继承呢?
		A:继承体现的是：is a的关系。
		B:采用假设法
	(8)Java继承中的成员关系
		A:成员变量
			a:子类的成员变量名称和父类中的成员变量名称不一样，这个太简单
			b:子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢?
				子类的方法访问变量的查找顺序：
					在子类方法的局部范围找，有就使用。
					在子类的成员范围找，有就使用。
					在父类的成员范围找，有就使用。
					找不到，就报错。
class B{
	int i = 100;
}

class A extends B{
	void print(){
		System.out.println(i);   -----------------A中虽然没有i，但是继承了B，所以不会报错
	}
}

-----------------------------------------------------------

		B:构造方法
			a:子类的构造方法默认会去访问父类的无参构造方法 -------------就是说子类的构造方法中第一句默认都是super()；
				是为了子类访问父类数据的初始化
			b:父类中如果没有无参构造方法，怎么办?
				子类通过super去明确调用带参构造
				子类通过this调用本身的其他构造，但是一定会有一个去访问了父类的构造
				让父类提供无参构造
           ---------------------this 和super必须放在构造方法的第一句。
		------------------也就是字一个构造方法中调用另一个构造方法，这就要用this来完成
----------------------要知道，如果子类没有调用父类的构造方法，肯定会报错，必须要有一个。经过测试证明

---------------------------------------------------------------
继承的成员变量赋值先后：
子继承父的，首先是全部执行父里面的成员初始化，后面才是初始化子的
class fu{
	static{System.out.println("fu d static");}----------------最先加载class文件的时候就加载了
	{System.out.println("fu d no static");}   ----------------这个没有static，就是创建该对象的时候加载的
	public fu(){                              ----------------这是创建对象最后执行的
		System.out.println("fu d 构造");
	}
}
class zi extends fu{
	static {System.out.println("zi d static");} --------------同样是加载class文件的时候加载执行的
	{System.out.println("zi d no static");}     --------------创建该对象的时候执行的
	
	public zi(){         -------------------------------------因为这里有个隐含的super()，所以先会去执行创建fu对象过程
		System.out.println("zi d 构造");            ------最后才是执行zi的构造    
	}
}
执行结果：
fu d static
zi d static
fu d no static
fu d 构造
zi d no static
zi d 构造
但是要注意，不管是构造还是static类成员变量，必须在main中创建子对象才会加载这些，并不是加载class文件就跟对象无关了
---------------------------------------------------------------
		C:成员方法
			a:子类的成员方法和父类中的成员方法名称不一样，这个太简单
			b:子类的成员方法和父类中的成员方法名称一样，这个怎么访问呢?
				通过子类对象访问一个方法的查找顺序：
					在子类中找，有就使用
					在父类中找，有就使用
					找不到，就报错
	(9)两个面试题：
		A:Override和Overload的区别?Overload是否可以改变返回值类型?
		B:this和super的区别和各自的作用?
	(10)数据初始化的面试题
		A:一个类的初始化过程          
--------------------------------------------------------------
初始化过程总结：
如果有static代码块或static成员变量，都先按分层依次执行（爷->父亲->子）
然后就是按照普通成员初始化：
1 默认初始化
2 显示初始化
3 构造方法初始化
注意：虽然子类中构造方法默认有一个super()，但是初始化的时候，不是按照那个顺序进行的，而是按照分层初始化的进行的。
--------------------------------------------------------------
		B:子父类的构造执行过程
		C:分层初始化
	(11)案例：
		A:学生和老师案例
			继承前
			继承后
		B:猫狗案例的分析和实现
		
		
方法重写：  子类中出现了了和父类中的方法声明一模一样的方法，如果参数不一样，就没有完成重写，父亲的方法还是可以调用--------------也叫作覆盖
            方法重写场景，就是在子类同名的方法中，通过super（）来，调用父类的方法，同时给出自己新增的方法
      重写注意：不能重写父类中的私有方法
                    子类重写父类方法的时候，如果遇到static，则两则都保持一致就不会报错  
方法重载：  本类出现的方法名一样，参数列表不同的方法，与返回值无关

























