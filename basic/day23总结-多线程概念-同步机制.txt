1:多线程(理解)
	(1)多线程：一个应用程序有多条执行路径
		进程：正在执行的应用程序
			--------通过任务管理器就可以看到进程的存在，概念：正在运行的程序，是系统进行资源分配和和调度的独立单位
			--------每一个进程都有自己的内存空间和系统资源
			--------多进程实现多程序同时进行（这是宏观上的同时）

		线程：进程的执行单元，执行路径---------------------线程依赖进程存在
			--------一个进程中有多个任务，每个任务叫做线程，线程是cpu执行的最小单位
		单线程：一个应用程序只有一条执行路径
		多线程：一个应用程序有多条执行路径
		
		多进程的意义?
			提高CPU的使用率
		多线程的意义?
			提高应用程序的使用率---------更有效抢到CUP资源，让进程执行效率增加
			随机性，就是每个线程抢到资源的不确定性

----------------------------------------------------------------------------
 *  大家注意两个词汇的区别：并行和并发。
 *		前者是逻辑上同时发生，指在某一个时间内同时运行多个程序。
 *		后者是物理上同时发生，指在某一个时间点同时运行多个程序。

 * Java程序的运行原理：
 * 		由java命令启动JVM，JVM启动就相当于启动了一个进程。
 * 		接着有该进程创建了一个主线程去调用main方法。
 * 
 * 思考题：
 * 		jvm虚拟机的启动是单线程的还是多线程的?
 * 			多线程的。
 * 			原因是垃圾回收线程也要先启动，否则很容易会出现内存溢出。
 * 			现在的垃圾回收线程加上前面的主线程，最低启动了两个线程，所以，jvm的启动其实是多线程的。

 * 如何实现呢?
 * 		由于线程是依赖进程而存在的，所以我们应该先创建一个进程出来。
 * 		而进程是由系统创建的，所以我们应该去调用系统功能创建一个进程。
 * 		Java是不能直接调用系统功能的，所以，我们没有办法直接实现多线程程序。
 * 		但是呢?Java可以去调用C/C++写好的程序来实现多线程程序。
 * 		由C/C++去调用系统功能创建进程，然后由Java去调用这样的东西，
 * 		然后提供一些类供我们使用。我们就可以实现多线程程序了。
 * 那么Java提供的类是什么呢?
 * 		Thread
 * 		通过查看API，我们知道了有2中方式实现多线程程序。
		A:继承Thread类
		B:实现Runnable接口

面试题：(区别)
	run():仅仅是封装被线程执行的代码，直接调用跟普通和方法一致
	start():首先启动了线程，然后再由jvm调用该线程的run()方法
面试题：
	my.start()调用两次会报错，为什么？
	因为start是启动线程，不能理解成执行，启动被调用了两次，故会报错，也就是不能启动线程两次
	所以要实现多线程，就要创建多个线程执行

因为线程都是随机执行，那如何分辨？-----------------获取名称哪有如何获取呢？
	---------直接调用.getName()即可
	---------如何设置呢？--------setName()
	-----------------------------其实在创建线程的时候就可设置名称，就是带参数的构造方法，但是要调用父类的构造方法
	-------如何获取当前线程名称：
		public static Thread currentThread():返回当前正在执行的线程对象
		eg：Thread.currentThread().getName();-------------用来看main方法线程的名称是：main


----------------------------------------------------------------------------

	(2)Java程序的运行原理及JVM的启动是多线程的吗?
		A:Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。
		B:JVM的启动是多线程的，因为它最低有两个线程启动了，主线程和垃圾回收线程。
	(3)多线程的实现方案(自己补齐步骤及代码	掌握)
		A:继承Thread类
		  步骤
		  		A:自定义类MyThread继承Thread类。
		  		B:MyThread类里面重写run()?   ----------------不重写不会报错，因为他是一个类，又不是抽象的
		  			为什么是run()方法呢?
		  		C:创建对象            Thread thread = new MyThread();------这种方式很简单，利用多态实现
		  		D:启动线程

		B:实现Runnable接口
		  步骤：---注意：这种方法就不能直接使用Thread方法了，因为上级是接口，但是可以获得该类对象来实现currentThread（间接使用）
 				A:自定义类MyRunnable实现Runnable接口
 				B:重写run()方法
 				C:创建MyRunnable类的对象
		 		D:创建Thread类的对象，并把C步骤的对象作为构造参数传递
		代码：
			MyRunnable my = new MyRunnable();
			// 创建Thread类的对象，并把C步骤的对象作为构造参数传递
			// Thread(Runnable target)
			// Thread t1 = new Thread(my);
			// Thread t2 = new Thread(my);
			// t1.setName("林青霞");
			// t2.setName("刘意");
			// Thread(Runnable target, String name)
			Thread t1 = new Thread(my, "林青霞");--------------直接就设置线程名称了
			Thread t2 = new Thread(my, "刘意");  --------------直接就设置线程名称了

-------------引入方式2原因：
			可以避免由于Java单继承带来的局限性
			适合多个相同程序的代码去处理同一个资源情况，把线程同程序的代码、数据有效分离，较好的体现了面向对象设计思想
		-----方式2常用

	(4)线程的调度和优先级问题
		A:线程的调度
			a:分时调度
			b:抢占式调度 (Java采用的是该调度方式)
------------------------------------------------------------------
如何设置线程的优先级？
	public final int getPriority()：返回线程的优先级----------默认是5
	public final int setPriority(int priority)：设置线程优先级

优先级：优先级高的优先使用CPU，并且分配的时间也多一些。但是注意：有时候还是很出现不确定性
------------------------------------------------------------------
		B:获取和设置线程优先级
			a:默认是5
			b:范围是1-10              
	(5)线程的控制(常见方法)
		A:休眠线程
			public static void sleep(long millis)
			try{
				Thread.sleep(1000);毫秒值---------------这句代码往往是放在run里面的，而不是外部调用
									因为它是指的当前线程，谁就休眠，外面调用就是mian休眠
			}catch (InterruptedExcepetion e){

			}

		B:加入线程
			public final void join():等待该线程终止，意思就是不管还有多少线程没有执行完毕，都要等该线程执行完后才能它们才能执行
				这个方法放在要join对象的开始之后，也就是在它本身的start方法之后。
		C:礼让线程
			public static void yield():暂停当前正在执行的线程对象，并执行其他线程-------就是让自己暂停一会儿然后再执行
				可以多个线程更和谐一些，但不能靠它让线程一人一次。但是测试下来效果不是很明显
				测试的时候这个方法是放在run的里面

		D:后台线程
			* public final void setDaemon(boolean on):将该线程标记为守护线程或用户线程。
 			* 当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。 ---可以这么理解：主线程或者不是守护线程
						结束后，不管守护线程还有多少，JVM都结束所有线程的，停止退出。
			设置代码：
				td1.setDaemon(true);
				td2.setDaemon(true);
					--------注意：都是在要设置的线程执行前。
				td1.start();
				td2.start();
 
		E:终止线程(掌握)
			 * public final void stop():让线程停止，过时了，但是还可以使用。---由于存在不安全性，被弃用了
						谁调用它谁就被终止。一旦调用了，该线程后面所有代码都不会执行。
			 * public void interrupt():中断线程。 把线程的状态（后面会讲状态）终止，并抛出一个InterruptedException。后面的代码会被执行
						（貌似是别的线程来执行的）
-------------------------------------------------------------------------
关于interrupt()还有很多疑问：
	目前了解是：直接调用stop会造成一些错误性。
	通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理中断。当调用interrupt()方法的时候,只是设
	置了要中断线程的中断状态，而此时被中断的线程的可以通过isInterrupted()或者是interrupted（）方法判断当前线程的中断状态是
	否标志为中断。
-------------------------------------------------------------------------
	(6)线程的生命周期(参照	线程生命周期图解.bmp)
		A:新建---创建线程对象
		B:就绪---有执行资格，没有执行权
		C:运行---有执行资格和执行权
		D:阻塞---一些操作让线程处于了该状态，没有执行资格，没有执行权
			而另一些操作却可以它激活，处于就绪状态
		E:死亡---线程对象编程垃圾，等待被回收
	(7)电影院卖票程序的实现
		A:继承Thread类----------------------让票数成员变量为static--------出现问题：有时候会出现同张票
		B:实现Runnable接口------------------不管是不是static ，都可以满足----出现问题：延迟后卖票出现问题
	(8)电影院卖票程序出问题
		A:为了更符合真实的场景，加入了休眠100毫秒。
		B:卖票问题
			a:同票多次           ------------视频中以解释
			b:负数票             ------------视频中以解释
				最主要原因：CPU执行的是原子，大家都是随机性。

	(9)多线程安全问题的原因(也是我们以后判断一个程序是否有线程安全问题的依据)
		A:是否有多线程环境             -----------我们是多线程
		B:是否有共享数据               -----------票就是共享数据
		C:是否有多条语句操作共享数据   -----------有判断，有自减，和输出
					       -----------所以我们的设计有问题

	(10)同步解决线程安全问题            -------------把多条语句包成一体
		A:同步代码块
			synchronized(对象) {
				需要被同步的代码;
			}
			
			这里的锁对象可以是任意对象。
----------------------------------------------------------------
 * 		A:对象是什么呢?
 * 			我们可以随便创建一个对象试试。
 * 		B:需要同步的代码是哪些呢?
 * 			把多条语句操作共享数据的代码的部分给包起来
 * 
 * 		注意：
 * 			同步可以解决安全问题的根本原因就在那个对象上。该对象如同锁的功能。
 * 			多个线程必须是同一把锁。
----------------------------------------------------------------
			
		B:同步方法
			把同步加在方法上。
			
			这里的锁对象是this
---------------------------------------------------------------
注意：synchronized(new Object())----这是无效的锁，因为每个对象都new了一个，所以大家的锁是不一样的，必须保证是同一个对象（任意对象都可以）
	{ 同步代码  }
	所以要将该对象设置为成员变量

 * 同步的好处 
 *		同步的出现解决了多线程的安全问题。
 * 同步的弊端
 *		当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。
---------------------------------------------------------------	
		
		C:静态同步方法
			把同步加在方法上。
			
			这里的锁对象是当前类的字节码文件对象(反射再讲字节码文件对象)
	(11)回顾以前的线程安全的类
		A:StringBuffer
		B:Vector
		C:Hashtable
		D:如何把一个线程不安全的集合类变成一个线程安全的集合类
			用Collections工具类的方法即可。里面有静态方法可以获取安全的集合
			eg:List<String> list = Collections.synchronizedList(new ArrayList<String>());----------这样就获得一个安全的List集合了


---------------------------------------------------------------------------------
同步总结：
	首先是要知道有三种同步
	1：同步代码块
		synchronized（之类的对象保证同一个即可）{}
	2：同步方法
		public synchronized void print（）{}
		这里的不能给出明确的锁对象，所以是默认的this
	3：静态方法同步
		public static synchronized void print（）{}
		这里同样不能给出明确的所对象，所以是默认的当前class的字节码对象：类名.class
		它在进入内存后就存在了，比静态方法还早存在

那么就不得不区分this和类名.class区别了
	this： 是代表new出来的的对象本身，也就是创建几个new对象，就有几个this，
		所以方式1（继承实现多线程）同步，如果这样设计就会出错，因为是要new多个线程对象，每个this都不同

	类名.class：   它是第一时间加载进入内存的字节码对象，不管该字节码对应的对象创建几个，它都只有一份
		所以用它来做锁，不管是方式1还是方式2，都能实现同步  



























