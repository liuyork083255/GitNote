1:登录注册案例(理解)

2:Set集合(理解)
	(1)Set集合的特点
		无序,唯一，不重复（这里的有无序指的是存取的顺序）
		---------------无序是因为底层依赖map实现的
	(2)HashSet集合(掌握)
		A:底层数据结构是哈希表(是一个元素为链表的数组)
		B:哈希表底层依赖两个方法：hashCode()和equals()
		  执行顺序：
			首先比较哈希值是否相同
				相同：继续执行equals()方法
					返回true：元素重复了，不添加
					返回false：直接把元素添加到集合
				不同：就直接把元素添加到集合
		C:如何保证元素唯一性的呢?
			由hashCode()和equals()保证的----------------自定义的就要自己重写
		D:开发的时候，代码非常的简单，自动生成即可。-----------------这里第一次看到重写hashcode方法的用处了
		E:HashSet存储字符串并遍历
		F:HashSet存储自定义对象并遍历(对象的成员变量值相同即为同一个元素)
----------------------------------------------------------------------
注意：了解哈希表的桶结构，只要值相同，就会装入桶中。
这里理解有点困难：
      首先比较哈希值，哈希值不同，则存放的地方是散开的，如果相同，此时equals比较不同，则肯定会存入，那么就会
      存到桶中，这里教程里面故意将所有的哈希值全改为了0，就是让他们存在一个桶中，那么效率很低。
      为什么这样存会低？
      因为将一个对象存入桶中，他会跟桶中所有的对象进行比较，这里的比较用的就是equals方法，这种方法逐一比较
      很费时间
      反过来想，如果哈希值不同，就不会比较equals方法了，这样的效率自然很高了。
      说白了就是想办法不要equals方法执行，这样效率就最高了-------------我们重写的目的就是解决尽量哈希值不同-----但是这可以自动生成
      


	private String name;
	private int age;
	private String address;

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((address == null) ? 0 : address.hashCode());
		result = prime * result + age;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}

----------------------------------------------------------------------
linkedhashset是hashset子集，就是多了link，这样本来的性质多了一个有序性，就是唯一性和有序性---------------这里的有序是存取顺序
----------------------------------------------------------------------
	(3)TreeSet集合-----注意：因为它是继承的set，所以他也是唯一性
		-----------------比如乱序存入integer类型，输出则是从小到大

		A:底层数据结构是红黑树(是一个自平衡的二叉树)---------------------意思就是会自动移动树结构，防止根为1，全部存右边的类似情况
		B:保证元素的排序方式
			a:自然排序(元素具备比较性)-----------构造不带参，TreeSet的构造
				让元素所属的类实现Comparable接口-----------里面比较的方法就是compareTo()，所以要使用该方法，就实现该接口
-------------------------------------------------------------------
这里是自然排序方法:
注意：如果我自定义的对象存入TreeSet中，因为没有实现comparable接口，这样就等于我们自定义类根本就不知晓按什么规则排序
	所以一个类想自然排序就必须实现comparable接口，重写当中的compareTo()方法

		不重写  添加则报错！！！！！！！！！！！！！！！

        他的返回值是：0  则表示相等，不存入
		      >0  表示大于比较的根，存右边
		      <0  表示小于比较的根，存左边
       在重写的时候我们只管负责自己按照自己的排序规则给出指定返回值即可

	字符串可以直接用compareTo方法，以为它实现了comparable接口中的compareTo方法

-------------------------------------------------------------------

			b:比较器排序(集合具备比较性)---------构造带参
				让集合构造方法接收Comparator的实现类对象
				这种方式就是构造方法给参数对象，而这个对象所属的类实现了Comparator接口，其实就是里面给出了两个对象的比较规则
------------------------------------------------------------------------------------------------------------------
这里是比较器排序：
		TreeSet<Student> ts = new TreeSet<Student>(new Comparator<Student>() {     -----------new 一个对象其实就是返回一个子类
			@Override
			public int compare(Student s1, Student s2) {    ---------------注意：这里重写的是compare方法，自然排序是重写compareTo方法
				// 姓名长度
				int num = s1.getName().length() - s2.getName().length();
				// 姓名内容
				int num2 = num == 0 ? s1.getName().compareTo(s2.getName()): num;
				// 年龄
				int num3 = num2 == 0 ? s1.getAge() - s2.getAge() : num2;
				return num3;
			}
		});
------------------------------------------------------------------------------------------------------------------

		C:把我们讲过的代码看一遍即可

取元素采用的是先序遍历
-------------------------------------------------------------------
	(4)案例：
		A:获取无重复的随机数
		B:键盘录入学生按照总分从高到底输出
		
3:Collection集合总结(掌握)
	Collection
		|--List	有序,可重复
			|--ArrayList
				底层数据结构是数组，查询快，增删慢。
				线程不安全，效率高
			|--Vector
				底层数据结构是数组，查询快，增删慢。
				线程安全，效率低
			|--LinkedList              -----------注意的是可以获取首尾的数据
				底层数据结构是链表，查询慢，增删快。
				线程不安全，效率高
		|--Set	无序,唯一
			|--HashSet  ---------------------------是通过map无序，通过hashCode和equals保证唯一
				底层数据结构是哈希表。
				如何保证元素唯一性的呢?
					依赖两个方法：hashCode()和equals()
					开发中自动生成这两个方法即可
				|--LinkedHashSet
					底层数据结构是链表和哈希表
					由链表保证元素有序
					由哈希表保证元素唯一
			|--TreeSet----------------------------是通过比较实现唯一和有序（Comparable和Comparator两个接口）
				底层数据结构是红黑树。
				如何保证元素排序的呢?
					自然排序
					比较器排序
				如何保证元素唯一性的呢?
					根据比较的返回值是否是0来决定
					
4:针对Collection集合我们到底使用谁呢?(掌握)
	唯一吗?
		是：Set
			排序吗?
				是：TreeSet
				否：HashSet
		如果你知道是Set，但是不知道是哪个Set，就用HashSet。
			
		否：List
			要安全吗?
				是：Vector
				否：ArrayList或者LinkedList
					查询多：ArrayList
					增删多：LinkedList
		如果你知道是List，但是不知道是哪个List，就用ArrayList。
	
	如果你知道是Collection集合，但是不知道使用谁，就用ArrayList。
	
	如果你知道用集合，就用ArrayList。
	
5:在集合中常见的数据结构(掌握)
	ArrayXxx:底层数据结构是数组，查询快，增删慢
	LinkedXxx:底层数据结构是链表，查询慢，增删快
	HashXxx:底层数据结构是哈希表。依赖两个方法：hashCode()和equals()
	TreeXxx:底层数据结构是二叉树。两种方式排序：自然排序和比较器排序









		