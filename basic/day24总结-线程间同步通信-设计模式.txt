1:多线程(理解)
	(1)JDK5以后的针对线程的锁定操作和释放操作
		Lock锁
----------------------------------------------------------------------------
 * 虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，
 * 为了更清晰的表达如何加锁和释放锁,JDK5以后提供了一个新的锁对象Lock。
 * 
 * Lock：
 * 		void lock()： 获取锁。
 * 		void unlock():释放锁。  
 * ReentrantLock是Lock的实现类.

	经过测试后，这种方式的实现其实和synchronized原理一致的，都是要一个对象作为锁，我们要保证的就是对象锁唯一即可
        代码实现：
		private static Lock lock = new ReentrantLock();-------这里只要加了static 不管用哪种方式都可以实现同步
		try {
			// 加锁
			lock.lock();
			...........
			这里是同步代码块
			...........
		} finally {
			// 释放锁
			lock.unlock();
		}-------------------------这里掌握它的设锁和放锁技巧，这样避开了因异常而不能释放造成死锁的情况
					  如果不释放，别的线程就永远不能执行

----------------------------------------------------------------------------

	(2)死锁问题的描述和代码体现
		就是同步嵌套----------------------就目前理解，要死锁必须要嵌套，就是有两把锁
	
	(3)生产者和消费者多线程体现(线程间通信问题)
				-----------------------------这种要区分开电影院卖票，它只有出去的资源，没有进入的资源
		以学生作为资源来实现的
		
		资源类：Student
		设置数据类：SetThread(生产者)
		获取数据类：GetThread(消费者)
		测试类：StudentDemo
		
		代码：
			A:最基本的版本，只有一个数据。
			B:改进版本，给出了不同的数据，并加入了同步机制
			C:等待唤醒机制改进该程序，让数据能够实现依次的出现
				wait()
				notify()
				notifyAll() (多生产多消费)
			D:等待唤醒机制的代码优化。把数据及操作都写在了资源类中

整个过程中注意事项：

 * 问题1：按照思路写代码，发现数据每次都是:null---0
 * 原因：我们在每个线程中都创建了新的资源,而我们要求的时候设置和获取线程的资源应该是同一个
 * 如何实现呢?
 * 		在外界把这个数据创建出来，通过构造方法传递给其他的类。
 * 
 * 问题2：为了数据的效果好一些，我加入了循环和判断，给出不同的值,这个时候产生了新的问题
 * 		A:同一个数据出现多次
 * 		B:姓名和年龄不匹配
 * 原因：
 * 		A:同一个数据出现多次
 * 			CPU的一点点时间片的执行权，就足够你执行很多次。
 * 		B:姓名和年龄不匹配
 * 			线程运行的随机性
 * 线程安全问题：
 * 		A:是否是多线程环境		是
 * 		B:是否有共享数据		是
 * 		C:是否有多条语句操作共享数据	是
 * 解决方案：
 * 		加锁。
 * 		注意：
 * 			A:不同种类的线程都要加锁。
 * 			B:不同种类的线程加的锁必须是同一把。
-----------------------------------------------------------------------------------------------
等待消费机制：
	A:生产者
		先看是否有数据，有就等待，没有就生产，生产完之后通知消费者消费
	B:消费者
		先看是否有数据，有就消费，没有就等待。消费完之后通知生产者生产

为了解决这样的问题，Java就提供了一种机制，等待唤醒机制


***等待唤醒机制：
 * 		Object类中提供了三个方法：
 * 			wait():等待        -------------这个方法还有参数的，意思就是在等待指定时间后自动唤醒
 *							没有时间构造方法则表示必须等待唤醒机制才能被唤醒执行
 *					**********  经过自己的测试发现：wait()这个方法不但是让当前线程等待，还有就是释放锁----这个很重要
 * 			notify():唤醒单个线程
 *					---------这里注意：线程在哪里等待，那么就是在哪里醒过来的，不会从头走一遍
					---------需要注意的是：线程被唤醒后不是立马就能执行的，还要争抢CPU，后续还要经历同步阻塞的判断
 * 			notifyAll():唤醒所有线程
			注意：如果一个线程本来就是唤醒状态，再调用notify则会报错

 * 		为什么这些方法不定义在Thread类中呢?
 * 			这些方法的调用必须通过锁对象调用，而我们刚才使用的锁对象是任意锁对象。
 * 			所以，这些方法必须定义在Object类中。

	代码优化：
		就是前面讲的成员变量是public，应该改为private，对外界只提供方法，所以就成了同步方法了
		而这个时候调用wait（）和notify（）就通过this 或者 class文件对象了
			这取决于方法是否为静态
		最终版代码中：
	 		把Student的成员变量给私有的了。
	 		把设置和获取的操作给封装成了功能，并加了同步。
	 		设置或者获取的线程里面只需要调用方法即可。

                        简单的记忆就是  将锁和同步的代码都封装到了对象中，而线程里面只提供访问代码

-----------------------------------------------------------------------------------------------



	(4)线程组
	      主要作用：
		 * 线程组： 把多个线程组合到一起。
		 * 它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。
		查看组名：
			public final ThreadGroup getThreadGroup()：获得调用者的所属组
				在默认情况下，都属性main这个组，并且main方法自己也是这个组
		创建新组：
			ThreadGroup tg = new ThreadGroup("这是一个新的组");------------创建新组
			MyRunnable my = new MyRunnable();                  ------------创建实现Runnable接口的对象
			// Thread(ThreadGroup group, Runnable target, String name)  ---该方法就是可以分组的Thread构造方法
			Thread t1 = new Thread(tg, my, "林青霞");   -------------------创建线程，并分组
			Thread t2 = new Thread(tg, my, "刘意");     -------------------创建线程，并分组

			//通过组名称设置后台线程，表示该组的线程都是后台线程
			tg.setDaemon(true);              ------------可以看见方便性，其实组名称还有更多方法

----------------------------------------------------------------------------------------

	(5)线程池

		线程池的好处：线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。
		尤其是要使用大量周期短暂的线程，更应该考虑这种方式

 * 如何实现线程的代码呢?
 * 		A:创建一个线程池对象，控制要创建几个线程对象。
 * 			public static ExecutorService newFixedThreadPool(int nThreads)---这个方法可以创建指定个数的线程池
 * 		B:这种线程池的线程可以执行：
 * 			可以执行Runnable对象或者Callable对象代表的线程---Callable是方式3实现线程
 * 			做一个类实现Runnable接口。
 * 		C:调用如下方法即可
 * 			Future<?> submit(Runnable task)
 *			<T> Future<T> submit(Callable<T> task)
 *		D:我就要结束，可以吗?
				-----------------注意一个小细节：main中语句结束后，如果池中还有线程则main方法不会结束，因为它还准备给别的用
						除非调用下面的shutdown方法
 *			可以。pool.shutdown();

       具体代码：
		// 创建一个线程池对象，控制要创建几个线程对象。
		// public static ExecutorService newFixedThreadPool(int nThreads)
		ExecutorService pool = Executors.newFixedThreadPool(2);创建能装两个线程的线程池

		// 可以执行Runnable对象或者Callable对象代表的线程
		pool.submit(new MyRunnable());         -----这就将线程装入，并启动了它的run方法
		pool.submit(new MyRunnable());	       -----这就将线程装入，并启动了它的run方法

		//结束线程池
		pool.shutdown();如果没有这一句，主程序不会结束


-------------------------------------------------------------------------------------------------------------

	(6)多线程实现的第三种方案
		首先这中方式有一定的局限性：就是必须依赖线程池存在(它没有start方法)，不能像前面两种方法用Thread来接受
		其次是这个方法在执行后可以有返回值，这前面两种没有的工能
		最后是这个方式是个泛型

	实现代码：
		//创建线程池对象
		ExecutorService pool = Executors.newFixedThreadPool(2);---------创建池
		
		//可以执行Runnable对象或者Callable对象代表的线程
		pool.submit(new MyCallable());                 ------------创建Callable对象并放入池中
		pool.submit(new MyCallable());                             MyCallable是实现了Callable接口的实现类

		***注意它的泛型的使用，实现接口Callable<V>时，V是什么类型，call方法返回的就是什么类型

代码：
public class CallableDemo implements Callable<T>{

	@Override
	public <T> call() throws Exception {
		// TODO Auto-generated method stub
		return null;
	}

}

---------------------------------------------------------------------------------------------

	（7）匿名内部类线程：
				--------------注意两次run方法的位置。
	方式1：		new Thread(){
				public void run(){
					for(int i=0;i<100;i++){
						System.out.println("the number is " + i);
					}
				}
			}.start();

	方式2：		new Thread(new Runnable(){
				public void run(){
					for(int i=0;i<10;i++){
						System.out.println("hello java !");
					}
				}
			}){}.start();
-------------------------------------------------------------------------------------------------------------

	(8)多线程的面试题

		就是遇到匿名对象实现线程，如果Runnable接口和子类对象都实现run方法，则会不会报错，不报错则执行哪一个方法
		new Thread(new Runnable() {
			@Override
			public void run() {
				for (int x = 0; x < 100; x++) {
					System.out.println("hello" + ":" + x);
				}
			}
		}) {
			public void run() {
				for (int x = 0; x < 100; x++) {
					System.out.println("world" + ":" + x);
				}
			}
		}.start();

			答：不会报错，执行子类对象的run方法

-----------------------------------------------------------------------------------------------------
定时器
 * 定时器：可以让我们在指定的时间做某件事情，还可以重复的做某件事情。
 * 依赖Timer和TimerTask这两个类：
 * Timer:定时
 * 		public Timer()			-------------------构造方法
 * 		public void schedule(TimerTask task,long delay)------------------------给一个定时类对象，并指明多少时间后开始执行
 * 		public void schedule(TimerTask task,long delay,long period)
							------------第二个参数表示什么时候执行，第三个表示间隔多少时间再执行
 * 		public void cancel()            -----------取消定时器，因为不取消，程序是不会结束的

代码实现：
public class TimerDemo {
	public static void main(String[] args) {
		// 创建定时器对象
		Timer t = new Timer();
		// 3秒后执行爆炸任务
		// t.schedule(new MyTask(), 3000);
		//结束任务
		t.schedule(new MyTask(t), 3000);
	}
}

// 做一个任务
class MyTask extends TimerTask {         定时器必须要继承该抽象类

	private Timer t;-------------这样设计专门接收该对象，然后可以调用取消方法
	public MyTask(){}
	public MyTask(Timer t){
		this.t = t;
	}
	
	@Override
	public void run() {          ------重写抽象方法
		System.out.println("beng,爆炸了");
		t.cancel();                ------------通过这种方式来取消定时器，不然程序不结束
	}            之所以采用这种方式是因为如果在main中调用cancel，那么可能出现还没有等到定时器执行，这条取消语句就执行了，定时器就结束了

}
-----------------------------------------------------------------------------------------------------

2:设计模式(理解)
	(1)面试对象的常见设计原则
		单一
		开闭
		里氏
		依赖注入
		接口
		迪米特
	(2)设计模式概述和分类
		A:经验的总结
		B:三类
			创建型
			结构型
			行为型
	(3)改进的设计模式
		A:简单工厂模式
			-------------------------------------------------------------------------------
			这里教程中先设置了Animal抽象类，然后Dog和Cat继承
			方式1：
				简单的自己创建对象
			方式2：
				创建一个工厂，用静态方法createDog和createCat分别返回Dog和Cat方法
				（但是后面考虑到以后要加类，比如Pig类，那么这个工厂就要加createPig方法，所以又改进）
			方式3：
				在工厂里面创建一个静态方法接受String的参数，然后判断String是Dog还是Cat，最后分别返回对应对象

			缺点：后期不断加入动物，那么工厂会不断修改

			-------------------------------------------------------------------------------
		B:工厂方法模式
			-------------------------------------------------------------------------------
			这个模式是用来解决上面模式的缺点！！！
			思想：
				首先有一个接口工厂，然后下面创建实现工厂类，而这个工厂类就可以为外部提供生产。
				不管要什么动物，都只需要创建一个新的工厂类然后添加即可，不用修改原来的任何一处代码
			缺点：
				没增加一个动物类就要创建工厂和动物实现类，工作量增大
					Factory f = new DogFactory();     -------创建了接口工厂，和实现造狗的实现类工厂
					Animal a = f.createAnimal();      -------创建了接口动物，和具体实现类狗
			
		以上两种分析利大于弊就可以使用

			-------------------------------------------------------------------------------
		C:单例模式(掌握)
			单例模式思想：就是类在内存中只有一个对象
			如何保证这一点呢？
		 		A：把构造方法私有
		 		B:在成员位置自己创建一个对象
		 		C:通过一个公共的方法提供访问

			a:饿汉式         ---------------就是那个唯一的对象声明为了static 导致已加载该类对象就存在了

饿汉式代码：
public class Student {
	private Student() {
	}
	private static Student s = new Student();
	public static Student getStudent() {
		return s;
	}
}
			b:懒汉式         ---------------用的时候才创建，加一个判断，方法里面判断该类对象为空则创建，不为空则直接返回对象

懒汉式代码：
public class Teacher {
	private Teacher() {
	}
	private static Teacher t = null;
	public synchronized static Teacher getTeacher() {
		if (t == null) {
			t = new Teacher();
		}
		return t;
	}
}

 * 面试题：单例模式的思想是什么?请写一个代码体现。
 * 
 * 		开发：饿汉式(是不会出问题的单例模式)           -----------因为不会出现同步问题，它一加载就存在了
 * 		面试：懒汉式(可能会出问题的单例模式)           -----------因为这种模式经常用于多线程中，就有可能出现同步问题
 * 			A:懒加载(延迟加载)	
 * 			B:线程安全问题
 * 				a:是否多线程环境	是
 * 				b:是否有共享数据	是
 * 				c:是否有多条语句操作共享数据 	是


-----------------------------------------------------------------------------------------------------


	(4)Runtime
		JDK提供的一个单例模式应用的类。
		还可以调用dos命令。

		Runtime r  = Runtime.getRuntime();  ----------可以看出这就是单例模型
		try {
			r.exec("mspaint");       -----------这就打开了画板
		} catch (IOException e) {
			e.printStackTrace();
		}
			





























