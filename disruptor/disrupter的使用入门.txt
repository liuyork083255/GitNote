使用disrupter的步骤：

1 定义事件 event ：事件(Event)就是通过 Disruptor 进行交换的数据类型。
	public class LongEvent
	{
		private long value;

		public void set(long value)
		{
			this.value = value;
		}
	}

2 定义事件工厂 event factory
	首先明白这个工厂有什么用：
		事件工厂(Event Factory)定义了如何实例化前面第1步中定义的事件(Event)，需要实现接口 com.lmax.disruptor.EventFactory<T>。
		Disruptor 通过 EventFactory 在 RingBuffer 中预创建 Event 的实例。（因为ringbuffer里面都是实例，每次发布都是先获取然后再设值，最后发布）
		一个 Event 实例实际上被用作一个“数据槽”，发布者发布前，先从 RingBuffer 获得一个 Event 的实例，然后往 Event 实例中填充数据，
		之后再发布到 RingBuffer 中，之后由 Consumer 获得该 Event 实例并从中读取数据。

	public class LongEventFactory implements EventFactory<LongEvent>      ---------理解成就是初始化的时候要用到这个类
	{
		public LongEvent newInstance()
		{
			return new LongEvent();
		}
	}

3 定义事件处理的具体实现 ：通过实现接口 com.lmax.disruptor.EventHandler<T> 定义事件处理的具体实现。
	下面这个类的方法这样理解吧：每当消费者获取到一个时间的时候，就会调用这个方法来做一些处理

	public class LongEventHandler implements EventHandler<LongEvent>
	{
		public void onEvent(LongEvent event, long sequence, boolean endOfBatch)
		{
			System.out.println("Event: " + event);
		}
	}

4 启动disrupter
	分为几个小步骤：
		4.1 定义用于事件处理的线程池
			Disruptor 通过 java.util.concurrent.ExecutorService 提供的线程来触发 Consumer 的事件处理。
			ExecutorService executor = Executors.newCachedThreadPool();
		4.2 指定等待策略
			Disruptor 定义了 com.lmax.disruptor.WaitStrategy 接口用于抽象 Consumer 如何等待新事件，这是策略模式的应用。
			Disruptor 提供了多个 WaitStrategy 的实现，每种策略都具有不同性能和优缺点，根据实际运行环境的 CPU 的硬件特点选择恰当的策略，
			并配合特定的 JVM 的配置参数，能够实现不同的性能提升。
				例如，BlockingWaitStrategy、SleepingWaitStrategy、YieldingWaitStrategy 等，其中，
				BlockingWaitStrategy 是最低效的策略，但其对CPU的消耗最小并且在各种不同部署环境中能提供更加一致的性能表现；
				SleepingWaitStrategy 的性能表现跟 BlockingWaitStrategy 差不多，对 CPU 的消耗也类似，但其对生产者线程的影响最小，适合用于异步日志类似的场景；
				YieldingWaitStrategy 的性能是最好的，适合用于低延迟的系统。在要求极高性能且事件处理线数小于 CPU 逻辑核心数的场景中，推荐使用此策略；例如，CPU开启超线程的特性。
		4.3 启动
		
			EventFactory<LongEvent> eventFactory = new LongEventFactory();
			ExecutorService executor = Executors.newSingleThreadExecutor();
			int ringBufferSize = 1024 * 1024; // RingBuffer 大小，必须是 2 的 N 次方；
					
			Disruptor<LongEvent> disruptor = new Disruptor<LongEvent>(eventFactory,
							ringBufferSize, executor, ProducerType.SINGLE,
							new YieldingWaitStrategy());
					
			EventHandler<LongEvent> eventHandler = new LongEventHandler();
			disruptor.handleEventsWith(eventHandler);
					
			disruptor.start();

5 发布事件
	Disruptor 的事件发布过程是一个两阶段提交的过程：
	　　第一步：先从 RingBuffer 获取下一个可以写入的事件的序号；
	　　第二步：获取对应的事件对象，将数据写入事件对象；
	　　第三部：将事件提交到 RingBuffer;
	事件只有在提交之后才会通知 EventProcessor 进行处理；（EventProcessor 目前理解成用于通知消费者，这边已经发布，可以进行消费）

	// 发布事件；
	RingBuffer<LongEvent> ringBuffer = disruptor.getRingBuffer();
	long sequence = ringBuffer.next();//请求下一个事件序号；
		
	try {
		LongEvent event = ringBuffer.get(sequence);//获取该序号对应的事件对象；
		long data = getEventData();//获取要通过事件传递的业务数据；
		event.set(data);
	} finally{
		ringBuffer.publish(sequence);//发布事件；
	}
		 注意，最后的 ringBuffer.publish 方法必须包含在 finally 中以确保必须得到调用；如果某个请求的 sequence 未被提交，将会堵塞后续的发布操作或者其它的 producer。

6 关闭 disrupter

	disruptor.shutdown();//关闭 disruptor，方法会堵塞，直至所有的事件都得到处理；
	executor.shutdown();//关闭 disruptor 使用的线程池；如果需要的话，必须手动关闭， disruptor 在 shutdown 时不会自动关闭；	





























