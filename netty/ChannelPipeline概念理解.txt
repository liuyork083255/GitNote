
channelpipeline 里面是存放所有的handler，他们之间是以链表的形式结合在一起的，那他们的执行关系是怎么样的呢？
在以前的版本分为 inbound 和 outbound，但是现在在高版本中不存在这个了，统一就是一个链，
	分为写和读，分别对应 outbound 和 inbound，
	也就是说：在初始化的时候我们会加入一些 handler ，头 -> 尾，如果是读操作，那么就会 msg 依次会经过头，最后到尾，
	如果是写操作，那么就是依次经过尾，最后到头，他们都是共享一个pipeline容器的，只不过每个 handler 处理的任务不一样。
	
	这里有必要必须理解：每个handler里面都是自己重写的特定方法，他们分为入/出，也就是有的方法只会在读的时候会被触发执行，
	有的方法只会在写的时候被触发执行。比如 编解码的 encode 和 decode ：encode只会写的时候才会执行，decode只会读的时候执行。
	
	而且handler 都有终止 msg 流程的功能，也就是在处理完数据后，如果执行“放行”操作，那么这条 msg 就只会执行到这里，后面的handler不会执行。
	注意：这个终止很重要***********
		因为发现 有三个 编码的 encode 里面，第一个使用了list.add，那么第二个肯定就能执行，接着第二个里面不用这条语句，那么第三个肯定是不会执行，
		但是最后发现消息还是发送出去了，服务端仍然有数据到达。
		所以目前得出的结论是：
			一条消息应该是可以跑完整个handler链的，只不过对应的属性是有中断效果的，比如说encode事件，那么如果第一条消息就不设置list.add，那么后面的
			所有消息的encode都不执行了，但是消息还是传递下去了，后面的消息别的事件方法不会被影响。












