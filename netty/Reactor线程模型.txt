
参考链接：http://www.infoq.com/cn/articles/netty-high-performance

高效的Reactor线程模型
	常用的Reactor线程模型有三种，分别如下：
		1) Reactor单线程模型；
		2) Reactor多线程模型；
		3) 主从Reactor多线程模型

		
Reactor单线程模型，指的是所有的IO操作都在同一个NIO线程上面完成，NIO线程的职责如下：
	1) 作为NIO服务端，接收客户端的TCP连接；
	2) 作为NIO客户端，向服务端发起TCP连接；
	3) 读取通信对端的请求或者应答消息；
	4) 向通信对端发送消息请求或者应答消息。
	
	由于Reactor模式使用的是异步非阻塞IO，所有的IO操作都不会导致阻塞，理论上一个线程可以独立处理所有IO相关的操作。从架构层面看，一个NIO线程确实可以完成其承担的职责。
	对于一些小容量应用场景，可以使用单线程模型。但是对于高负载、大并发的应用却不合适，主要原因如下：
		1) 一个NIO线程同时处理成百上千的链路，性能上无法支撑，即便NIO线程的CPU负荷达到100%，也无法满足海量消息的编码、解码、读取和发送；
		2) 当NIO线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重了NIO线程的负载，
			最终会导致大量消息积压和处理超时，NIO线程会成为系统的性能瓶颈；
		3) 可靠性问题：一旦NIO线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。


Reactor多线程模型
	Rector多线程模型与单线程模型最大的区别就是有一组NIO线程处理IO操作
	Reactor多线程模型的特点：
		1) 有专门一个NIO线程-Acceptor线程用于监听服务端，接收客户端的TCP连接请求；
		2) 网络IO操作-读、写等由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，它包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送；
		3) 1个NIO线程可以同时处理N条链路，但是1个链路只对应1个NIO线程，防止发生并发操作问题。

		
在绝大多数场景下，Reactor多线程模型都可以满足性能需求；但是，在极特殊应用场景中，一个NIO线程负责监听和处理所有的客户端连接可能会存在性能问题。
	例如百万客户端并发连接，或者服务端需要对客户端的握手消息进行安全认证，认证本身非常损耗性能。在这类场景下，单独一个Acceptor线程可能会存在性能不足问题，
	为了解决性能问题，产生了第三种Reactor线程模型-主从Reactor多线程模型。

	主从Reactor线程模型的特点是：
		服务端用于接收客户端连接的不再是个1个单独的NIO线程，而是一个独立的NIO线程池。Acceptor接收到客户端TCP连接请求处理完成后（可能包含接入认证等），
		将新创建的SocketChannel注册到IO线程池（sub reactor线程池）的某个IO线程上，由它负责SocketChannel的读写和编解码工作。
		Acceptor线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端subReactor线程池的IO线程上，由IO线程负责后续的IO操作。

		
	利用主从NIO线程模型，可以解决1个服务端监听线程无法有效处理所有客户端连接的性能不足问题。因此，在Netty的官方demo中，推荐使用该线程模型。

	
	事实上，Netty的线程模型并非固定不变，通过在启动辅助类中创建不同的EventLoopGroup实例并通过适当的参数配置，就可以支持上述三种Reactor线程模型。
	正是因为Netty 对Reactor线程模型的支持提供了灵活的定制能力，所以可以满足不同业务场景的性能诉求。
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	