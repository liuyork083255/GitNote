
首先知道 UNIX 操作系统自己提供了 5种 IO模型：
	阻塞IO模型
	非阻塞IO模型
	IO多路复用模型：Linux提供了 select/poll 功能来实现复用，Linux还提供了一个epoll系统调用，基于事件驱动方式代替顺序扫描，性能更高
	信号驱动IO模型
	异步IO

着重了解IO多路复用技术，因为Java的NIO的核心类库多路复用器Selector就是基于epoll的多路复用技术

多路复用技术原理：
	IO多路复用技术通过吧多个IO阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。
	这样子系统的开销很小
	目前支持的IO复用的系统调用有 select pselect poll epoll，很长时间Linux使用select ，但是它有缺陷，最终选用epoll
	
	select 和 epoll 对比：
		1 select默认支持1024个连接，太少了，虽然可以更改数量，但是带来的网络效率下降不成正比；
		而epoll连接数则远远大于这个值

		2 select如果连接了很多socket集合，如果只要其中几个活跃，select 每次调用都会劝募扫描所有的集合，效率低（poll也是这样）
		而epoll 不存在这个问题，因为它是通过一个每个连接的回调函数来操作活跃的socket



		
		
		
BIO（阻塞）：
	通过三次握手建立连接，成功后双方通过 输入和输出流进行同步阻塞通信。
	特点:
		客户端连接和服务端线程 1:1正比关系
		服务端的监听客户端的连接是用while死循环来操作的


	改进（伪异步IO）：服务端采用线程池来操作，将每一个新连接封装成 task 交给线程池来处理，这样就不会出现线程无限增长，资源不会被耗尽而宕机了。
		底层只是加入了线程池，所以仍然还是同步IO处理机制
	
	同步问题分析：
		如果客户端连接后发送消息很慢，花了60s，那么服务端的对应的线程也会同步阻塞60s，再次期间，其他接入消息只能在消息队列中排队。
		服务端发送消息如果很慢，客户端也是同样慢

		
		
NIO（非阻塞）：
	在阻塞中使用的 java 类是 Socket 和 ServerSocket，NIO提供了对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道。
	这两个新的套接字支持同步和异步，可以根据需求自己选择。

	核心组件：
		缓冲区 Buffer：
			在NIO中，所有的数据都是通过 缓冲区处理的，读数据则是先读到缓冲区，写数据则是先写到缓冲区。
			有很多java基本类型的Buffer，常用的是 ByteBuffer，
		
		通道 Channel：
			Channel 是一个通道，可以通过它读取和写入数据，网络数据通过Channel读取和写入。
			通道和流的不同之处在于通道是双向的，流只是一个方向上移动，并且通道可以读，写或同事读写
			因此，Channel 是全双工的。
			可以这么理解：客户端先将数据写入缓冲区，缓冲区将数据写入通道，然后传输到服务端，服务端就先将数据从通道读入缓冲区，然后从缓冲区读取出来。

		多路复用器 Seletor：（我自己简称选择器吧）
			首先选择器会无限的轮询注册在其上的Channel，如果某个Channel上面有新的TCP连接接入、读和写事件，这个Channel就会处于就绪状态，被 选择器 轮询出来，
			然后通过SelectionKry可以获取就绪的Channel集合。
			
			这个Channel 的细节很多，需要好好理解，所以最好看原PDF ...
			
			需要注意的是：Channel是注册在Selector上的，一个Selector可以同时轮询多个Channel
				多路复用器关闭后，所有注册在上面的Channel 和 Pipe 等资源都会被自动释放资源。
			
		Reactor 线程：
			他理解成一个 代理的客户端连接的处理的中转站，多路复用器Seletor就是在这个线程中



AIO（异步）:
	JDK1.7 引入的新的异步通道概念 NIO2.0，并提供了异步文件通道和异步套接字通道的实现。
	这种异步是真正的异步非阻塞IO，它对应的 UNIX 网络编程中的事件驱动IO（AIO），它不需要通过多路复用器Selector的轮询























