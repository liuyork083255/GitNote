
中断的原理
	Java中断机制是一种协作机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理中断。
	这好比是家里的父母叮嘱在外的子女要注意身体，但子女是否注意身体，怎么注意身体则完全取决于自己。

	Java中断模型也是这么简单，每个线程对象里都有一个boolean类型的标识（不一定就要是Thread类的字段，实际上也的确不是，
	这几个方法最终都是通过native方法来完成的），代表着是否有中断请求（该请求可以来自所有线程，包括被中断的线程本身）。
	例如，当线程t1想中断线程t2，只需要在线程t1中将线程t2对象的中断标识置为true，然后线程2可以选择在合适的时候处理该中断请求，
	甚至可以不理会该请求，就像这个线程没有被中断一样。


java.lang.Thread类提供了几个方法来操作这个中断状态：

	public static boolean interrupted():
		测试当前线程是否已经中断。线程的中断状态由该方法清除。换句话说，如果连续两次调用该方法，
		则第二次调用将返回 false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。
	
	public boolean isInterrupted()
		测试线程是否已经中断。线程的中断状态不受该方法的影响。
	
	public void interrupt()
		中断线程。interrupt方法是唯一能将中断状态设置为true的方法。静态方法interrupted会将当前线程的中断状态清除，
		但这个方法的命名极不直观，很容易造成误解，需要特别注意

	在使用interrupt的时候，必须调用的那个线程已经启动了，否者就算了设置了标志，对应的线程的中断标志还是没有没有被标记。


	
	
现在基本的理解就是：
	如果使用这种机制则需要在特定的时间设置中断信号，被中断的线程自己需要判断是否被中断，可以使用上面的两个方法，注意他们的区别。
		如果判断中断信号为true，那么自己中断自己即可（当然是我们自己写程序中断，比如跑一个异常出来）
		
	需要注意的是，如果一个线程被设置了中断信号以后，那么再调用sleep方法，那么sleep（）方法不会执行，同时会清除掉该状态，并且抛出interruptedException异常。
		由于sleep本身需要try-catch处理，所以这个异常也被处理了，线程并没有停下来。
		而且sleep方法抛出这个异常之后会清除中断状态，所以我们需要重新标记这个异常


当然可以不使用这种机制，而是使用自己提供的一个变量来控制，原理其实也是一样的，都是判断一个条件是否成立，成立则自己用代码控制退出，不成立，则继续执行。










